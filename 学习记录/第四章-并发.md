# 并发编程

## 并发基础

- 并发能更客观的表现问题模型
- 并发可以充分利用CPU核心的优势，提高程序的执行效率
- 并发能充分利用CPU与其他硬件设备固有的异步性

### 并发的几种主流实现模型

#### 多进程

是在操作系统层面进行并发的基本模式，同时也是开销最大的模式

- 优点：简单、进程间互不影响
- 缺点：系统开销大，所有进程都由内核管理

#### 多线程

在大部分操作系统上都属于系统层面的并发模式，也是我们使用最多的最有效的一种模式

- 优点：比多进程开销小很多
- 缺点：但是开销依旧比较大，在高并发模式下，效率会有影响

#### 基于回调的非阻塞/异步IO

这种模式通过事件驱动的方式使用异步IO，是服务器持续运转，且尽可能少用线程，降低开销，在Node.js上得到了很好的实践

- 缺点：编程比多线程要更复杂，因为把流程做了分割，对于问题本身的反应不够自然

#### 协程

本质是一种用户态线程，不需要操作系统来进行抢占式调度，且在真正的实现中寄存于线程中

- 优点：系统开销极小，可以有效提高线程的任务并发性，而避免多线程的缺点
- 缺点：需要语言的支持，如果不支持，则需要用户在程序中自行实现调度器

## 多核并行化

**例子：**计算N个整型数的总和。

我们可以将所有整型数分成M份,M即CPU的个数。让每个CPU开始计算分给它的那份计算任务,最后将每个CPU的计算结果再做一次累加,这样就可以得到所有N个整型数的总和

```go
type Vector []float64

// 分配给每个CPU的计算任务
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
	for ; i < n; i++ {
		v[i] += u.Op(v[i])
	}
	c <- 1 // 告诉任务管理者，我已经计算完成了
}

const NCPU = 16 // 假设有16核

func (v Vector) DoAll(u Vector) {
	c := make(chan int, NCPU)

	for i := 0; i < NCPU; i++ {
		// 按核心个数，分配个数次的任务 平均任务
		go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c)
	}

	// 等待所有CPU的任务完成
	for i := 0; i < NCPU; i++ {
		<-c // 获取到一个数据，表示一个CPU计算完成
		fmt.Println("一个核心计算完成")
	}

	// 这里表示所有计算已经结束
	fmt.Println("全部计算完成")
}
```

## 同步锁

- sync.Mutex 暴力锁，阻止读写
- sync.RWMutex 经典的单写多读模型